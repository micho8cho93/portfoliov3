---
interface Props {
  title?: string;
}

const { title = 'Terminal Treasure Hunt' } = Astro.props;
const inputId = `linux-terminal-${Math.random().toString(36).slice(2, 10)}`;
---

<section class="linux-terminal-card" data-linux-terminal>
  <header class="linux-terminal-header">
    <h3>{title}</h3>
    <p>
      Find the hidden flag file by using: <code>ls</code>, <code>ls -a</code>, <code>cd</code>,
      <code>cd ..</code>, and <code>cat</code>.
    </p>
  </header>

  <ul class="linux-terminal-checklist" aria-label="Required commands">
    <li data-requirement="ls"><code>ls</code></li>
    <li data-requirement="ls -a"><code>ls -a</code></li>
    <li data-requirement="cd"><code>cd</code></li>
    <li data-requirement="cd .."><code>cd ..</code></li>
    <li data-requirement="cat"><code>cat</code></li>
  </ul>

  <div class="linux-terminal-shell" role="region" aria-label="Linux terminal emulator">
    <pre class="linux-terminal-output" data-output aria-live="polite"></pre>

    <form class="linux-terminal-input-row" data-form>
      <label class="sr-only" for={inputId}>Enter terminal command</label>
      <span class="linux-terminal-prompt" data-prompt aria-hidden="true"></span>
      <input
        id={inputId}
        class="linux-terminal-input"
        type="text"
        data-input
        autocomplete="off"
        autocapitalize="off"
        spellcheck="false"
      />
      <button type="submit" class="linux-terminal-button">Run</button>
      <button type="button" class="linux-terminal-button ghost" data-reset>Reset</button>
    </form>
  </div>

  <p class="linux-terminal-status" data-status aria-live="polite"></p>
</section>

<script is:inline>
  if (!window.__linuxTerminalBound) {
    window.__linuxTerminalBound = true;

    const requiredCommands = ['ls', 'ls -a', 'cd', 'cd ..', 'cat'];
    const homePath = ['home', 'student'];
    const startPath = [...homePath, 'projects'];
    const flagPath = ['home', 'student', '.vault', '.flag.txt'];

    const fileSystem = {
      type: 'dir',
      children: {
        home: {
          type: 'dir',
          children: {
            student: {
              type: 'dir',
              children: {
                projects: {
                  type: 'dir',
                  children: {
                    'welcome.txt': {
                      type: 'file',
                      content:
                        'Welcome to Intro to Linux.\nYou are in ~/projects.\nUse cd .. to go up, then ls -a to spot hidden entries.'
                    },
                    'notes.txt': {
                      type: 'file',
                      content: 'Hidden files and folders start with a dot.'
                    }
                  }
                },
                lessons: {
                  type: 'dir',
                  children: {
                    'commands.md': {
                      type: 'file',
                      content:
                        'Useful commands:\nls -> list files\nls -a -> include hidden files\ncd -> change directory\ncat -> read a file'
                    }
                  }
                },
                '.vault': {
                  type: 'dir',
                  children: {
                    'readme.txt': {
                      type: 'file',
                      content:
                        'Almost there.\nRun ls -a in this directory, then cat the hidden file.'
                    },
                    '.flag.txt': {
                      type: 'file',
                      content: 'flag{linux_navigation_complete}'
                    }
                  }
                }
              }
            }
          }
        }
      }
    };

    const clonePath = (path) => [...path];

    const pathMatches = (a, b) => a.length === b.length && a.every((segment, index) => segment === b[index]);

    const getNode = (path) => {
      let node = fileSystem;
      for (const segment of path) {
        if (!node || node.type !== 'dir') {
          return null;
        }
        node = node.children[segment];
      }
      return node ?? null;
    };

    const formatPath = (path) => {
      const isHomePrefix = path.length >= homePath.length && homePath.every((segment, index) => path[index] === segment);
      if (isHomePrefix) {
        if (path.length === homePath.length) {
          return '~';
        }
        return `~/${path.slice(homePath.length).join('/')}`;
      }

      return path.length ? `/${path.join('/')}` : '/';
    };

    const formatPrompt = (path) => `learner@linux:${formatPath(path)}$`;

    const updateChecklist = (container, usedCommands) => {
      container.querySelectorAll('[data-requirement]').forEach((item) => {
        const requirement = item.getAttribute('data-requirement') ?? '';
        const isDone = usedCommands.has(requirement);
        item.classList.toggle('done', isDone);
      });
    };

    const setStatus = (statusEl, usedCommands, foundFlag) => {
      const missing = requiredCommands.filter((command) => !usedCommands.has(command));
      if (foundFlag && missing.length === 0) {
        statusEl.textContent = 'Challenge complete: all required commands used and flag captured.';
        return;
      }

      if (foundFlag) {
        statusEl.textContent = `Flag found. Remaining command(s): ${missing.join(', ')}`;
        return;
      }

      statusEl.textContent = `Remaining command(s): ${missing.join(', ')}`;
    };

    const bootLines = () => [
      'Linux practice terminal ready.',
      'Goal: find and print the hidden flag file.',
      'Type help to see available commands.'
    ];

    const bindTerminal = (container) => {
      if (!(container instanceof HTMLElement) || container.dataset.bound === 'true') {
        return;
      }

      const outputEl = container.querySelector('[data-output]');
      const promptEl = container.querySelector('[data-prompt]');
      const inputEl = container.querySelector('[data-input]');
      const formEl = container.querySelector('[data-form]');
      const resetButton = container.querySelector('[data-reset]');
      const statusEl = container.querySelector('[data-status]');

      if (
        !(outputEl instanceof HTMLElement) ||
        !(promptEl instanceof HTMLElement) ||
        !(inputEl instanceof HTMLInputElement) ||
        !(formEl instanceof HTMLFormElement) ||
        !(resetButton instanceof HTMLButtonElement) ||
        !(statusEl instanceof HTMLElement)
      ) {
        return;
      }

      container.dataset.bound = 'true';

      const state = {
        currentPath: clonePath(startPath),
        lines: bootLines(),
        usedCommands: new Set(),
        foundFlag: false
      };

      const appendLine = (line = '') => {
        state.lines.push(line);
      };

      const render = () => {
        outputEl.textContent = state.lines.join('\n');
        outputEl.scrollTop = outputEl.scrollHeight;
        promptEl.textContent = formatPrompt(state.currentPath);
        updateChecklist(container, state.usedCommands);
        setStatus(statusEl, state.usedCommands, state.foundFlag);
      };

      const currentDirectory = () => {
        const node = getNode(state.currentPath);
        return node && node.type === 'dir' ? node : null;
      };

      const runLs = (args) => {
        const hasDashA = args.includes('-a');
        const validArgs = args.length === 0 || (args.length === 1 && hasDashA);
        if (!validArgs) {
          appendLine('Usage: ls or ls -a');
          return;
        }

        state.usedCommands.add('ls');
        if (hasDashA) {
          state.usedCommands.add('ls -a');
        }

        const directory = currentDirectory();
        if (!directory) {
          appendLine('ls: unable to read current directory');
          return;
        }

        const entries = Object.keys(directory.children).sort((a, b) => a.localeCompare(b));
        const visibleEntries = hasDashA
          ? ['.', '..', ...entries]
          : entries.filter((name) => !name.startsWith('.'));

        appendLine(visibleEntries.length > 0 ? visibleEntries.join('  ') : '(empty)');
      };

      const runCd = (args) => {
        if (args.length > 1) {
          appendLine('Usage: cd <directory>');
          return;
        }

        state.usedCommands.add('cd');
        const target = args[0] ?? '~';

        if (target.includes('/')) {
          appendLine('cd: use one directory at a time in this lesson.');
          return;
        }

        if (target === '~') {
          state.currentPath = clonePath(homePath);
          return;
        }

        if (target === '..') {
          state.usedCommands.add('cd ..');
          if (state.currentPath.length > 0) {
            state.currentPath = state.currentPath.slice(0, -1);
          }
          return;
        }

        if (target === '.') {
          return;
        }

        const directory = currentDirectory();
        const nextNode = directory?.children?.[target];
        if (!nextNode) {
          appendLine(`cd: no such file or directory: ${target}`);
          return;
        }

        if (nextNode.type !== 'dir') {
          appendLine(`cd: not a directory: ${target}`);
          return;
        }

        state.currentPath = [...state.currentPath, target];
      };

      const runCat = (args) => {
        if (args.length !== 1) {
          appendLine('Usage: cat <file>');
          return;
        }

        state.usedCommands.add('cat');
        const target = args[0];

        if (target.includes('/')) {
          appendLine('cat: use a file in the current directory for this lesson.');
          return;
        }

        const directory = currentDirectory();
        const entry = directory?.children?.[target];
        if (!entry) {
          appendLine(`cat: ${target}: No such file`);
          return;
        }

        if (entry.type !== 'file') {
          appendLine(`cat: ${target}: Is a directory`);
          return;
        }

        appendLine(entry.content);

        const activeFilePath = [...state.currentPath, target];
        if (pathMatches(activeFilePath, flagPath)) {
          state.foundFlag = true;
        }
      };

      const runCommand = (rawInput) => {
        const commandLine = rawInput.trim();
        if (!commandLine) {
          return;
        }

        appendLine(`${formatPrompt(state.currentPath)} ${commandLine}`);

        const [command, ...args] = commandLine.split(/\s+/);

        switch (command) {
          case 'help':
            appendLine('Available commands: ls, ls -a, cd, cd .., cat, pwd, clear');
            break;
          case 'pwd':
            appendLine(state.currentPath.length ? `/${state.currentPath.join('/')}` : '/');
            break;
          case 'clear':
            state.lines = [];
            break;
          case 'ls':
            runLs(args);
            break;
          case 'cd':
            runCd(args);
            break;
          case 'cat':
            runCat(args);
            break;
          default:
            appendLine(`${command}: command not found`);
        }
      };

      formEl.addEventListener('submit', (event) => {
        event.preventDefault();
        const command = inputEl.value;
        inputEl.value = '';
        runCommand(command);
        render();
        inputEl.focus();
      });

      resetButton.addEventListener('click', () => {
        state.currentPath = clonePath(startPath);
        state.lines = bootLines();
        state.usedCommands.clear();
        state.foundFlag = false;
        render();
        inputEl.focus();
      });

      render();
    };

    const init = () => {
      document.querySelectorAll('[data-linux-terminal]').forEach(bindTerminal);
    };

    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', init, { once: true });
    } else {
      init();
    }
  }
</script>

<style>
  .linux-terminal-card {
    margin-top: var(--space-md);
    border: 1px solid var(--line);
    border-radius: var(--radius-md);
    background: var(--bg-elevated);
    overflow: hidden;
  }

  .linux-terminal-header {
    padding: var(--space-sm) var(--space-md);
    border-bottom: 1px solid var(--line);
    background: color-mix(in srgb, var(--accent-2) 8%, var(--bg-elevated));
  }

  .linux-terminal-header h3 {
    margin-bottom: var(--space-xs);
    font-size: 1.2rem;
  }

  .linux-terminal-header p {
    margin-bottom: 0;
  }

  .linux-terminal-checklist {
    list-style: none;
    display: flex;
    flex-wrap: wrap;
    gap: var(--space-xs);
    padding: var(--space-sm) var(--space-md);
    margin: 0;
    border-bottom: 1px solid var(--line);
    background: color-mix(in srgb, var(--accent-1) 4%, var(--bg-elevated));
  }

  .linux-terminal-checklist li {
    margin: 0;
    padding: 0.22rem 0.5rem;
    border-radius: var(--radius-pill);
    border: 1px solid var(--line);
    background: var(--bg-elevated);
    color: var(--ink-muted);
    font-size: 0.82rem;
  }

  .linux-terminal-checklist li.done {
    border-color: color-mix(in srgb, var(--accent-1) 45%, var(--line));
    background: color-mix(in srgb, var(--accent-1) 15%, var(--bg-elevated));
    color: var(--ink-primary);
  }

  .linux-terminal-checklist code {
    font-size: 0.82rem;
  }

  .linux-terminal-shell {
    border-top: 1px solid color-mix(in srgb, var(--ink-primary) 12%, transparent);
    background: #000;
    color: #f5f5f5;
  }

  .linux-terminal-output {
    margin: 0;
    min-height: 14rem;
    max-height: 20rem;
    overflow: auto;
    padding: var(--space-sm);
    white-space: pre-wrap;
    word-break: break-word;
    font-family: var(--font-mono);
    font-size: 0.88rem;
    line-height: 1.45;
    background: #000;
    color: #f5f5f5;
  }

  .linux-terminal-input-row {
    display: grid;
    grid-template-columns: auto minmax(0, 1fr) auto auto;
    gap: var(--space-xs);
    align-items: center;
    padding: var(--space-sm);
    border-top: 1px solid rgb(217 239 233 / 22%);
    background: #000;
  }

  .linux-terminal-prompt {
    font-family: var(--font-mono);
    font-size: 0.82rem;
    white-space: nowrap;
    color: #8dfdd3;
  }

  .linux-terminal-input {
    width: 100%;
    border: 1px solid rgb(217 239 233 / 26%);
    border-radius: var(--radius-sm);
    background: #060606;
    color: #f5f5f5;
    padding: 0.45rem 0.58rem;
    font-family: var(--font-mono);
    font-size: 0.85rem;
  }

  .linux-terminal-input::placeholder {
    color: rgb(217 239 233 / 55%);
  }

  .linux-terminal-button {
    border: 1px solid rgb(217 239 233 / 28%);
    border-radius: var(--radius-sm);
    padding: 0.4rem 0.7rem;
    background: color-mix(in srgb, #2f9e7a 45%, #111);
    color: #fff;
    font-size: 0.82rem;
    cursor: pointer;
  }

  .linux-terminal-button.ghost {
    background: #060606;
  }

  .linux-terminal-status {
    margin: 0;
    padding: var(--space-xs) var(--space-md) var(--space-sm);
    font-size: 0.85rem;
    color: var(--ink-muted);
  }

  .sr-only {
    position: absolute;
    width: 1px;
    height: 1px;
    padding: 0;
    margin: -1px;
    overflow: hidden;
    clip: rect(0, 0, 0, 0);
    white-space: nowrap;
    border: 0;
  }

  @media (max-width: 42rem) {
    .linux-terminal-input-row {
      grid-template-columns: 1fr;
      align-items: stretch;
    }

    .linux-terminal-prompt {
      white-space: normal;
    }
  }
</style>
